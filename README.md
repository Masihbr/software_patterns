# کاربرد عملی الگوهای طراحی شئ‌گرا (Object Oriented Design Patterns) 
در این مخزن یک سیستم ارسال محصول برای استفاده از طراحی‌های شئ‌گرا به صورت TDD توسعه یافته است.

## الگوی طراحی States
یک کلاس ابسترکت پایه برای State های مختلف در نظر می‌گیریم که دو تابع transfer_product و deliver_product در آن قرار دارد. همه ساب کلاس ها باید این توابع را پیاده سازی کنند و با توجه به منطق برنامه تغییری روی product (حالت یا مقادیرش) ایجاد کنند. این طراحی بر اساس [این لینک](https://refactoring.guru/design-patterns/state) انجام شده و در کلاس Product که Context اصلی به حساب می‌آید نیز توابعی که در کلاس State وجود دارد پیاده سازی شده بدین صورت که این توابع، تابع نظیر در state ای که در آن قرار دارند را کال می‌کنند. همچنین برای کم کردن وابستگی Product به State و انتزاعی تر شدن کار فقط در State ها با استفاده از توابع Setter تغییر روی Product انجام می‌شود و لازم نیست که با اضافه شدن State جدید تغییری در کلاس Product داشته باشیم.
![image](https://github.com/Masihbr/software_patterns/assets/56260232/39c895b6-3119-486e-8001-b5cc6f488057)
![image](https://github.com/Masihbr/software_patterns/assets/56260232/028391d7-01da-429a-a01f-6ece17e99ffc)


## روند TDD
ابتدا تست‌های مربوط به هر بخش نوشته شده و سپس کد برای پاس کردن تست‌ها اضافه شده مانند دو تصویر زیر که اینکار برای توسعه تمام بخش‌ها انجام انجام شده (در آزمایش TDD توضیحات کامل این روش وجود دارد و از تکرار پرهیز می‌کنیم):
![image](https://github.com/Masihbr/software_patterns/assets/56260232/435a85d7-36d8-4213-9e52-93a28a1ef092)
![image](https://github.com/Masihbr/software_patterns/assets/56260232/9730dc67-0131-4f88-88dd-367e02f69a3c)




##  پرسش ها
### پرسش ۱
در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.
#### پاسخ:
سه دسته الگو در این کتاب وجود دارد، الگوهای ایجادی(Creational Patterns)، الگو‌های ساختاری (Structural Patterns)، و الگو‌های رفتاری (Behavioral Patterns).
<br/>
دسته اول الگوهای ایجادی(Creational Patterns):
<br/>
هدف این دسته الگو‌های طراحی‌، ایجاد مکانیزم‌های ساخت شی ایست که در نتیجه آن بتوان ساخت شی را به صورت reusable و منعطف انجام داد. به طور مثال Singleton یک نمونه از الگوی Creational  است که باعث می‌شود از یک کلاس فقط یک شی ایجاد شود. از این الگو برای ساختن درگاه های ارتباطی با پایگاه‌داده‌ها (یا به طور کلی منابع مشترک) استفاده می‌شود. مثال دیگر از گروه الگوی Creational الگوی factory است که در آن یک کلاس سازنده تعریف می‌شود که بر اساس ورودی‌ها و شرایط مورد نیاز برنامه شی های متفاوت می‌سازد. 
<br/>
دسته دوم الگوهای ساختاری(Structural Patterns):
<br/>
الگوهای ساختاری روش‌هایی برای سازماندهی اشیا و کلاس‌ها ارائه می‌دهند تا این موارد بتوانند با هم به صورت انعطاف پذیر و بهینه کار کنند و سیستم‌های بزرگتر و پیچیده‌تر را تشکیل دهند. منظور از انعطاف پذیر و بهینه بودن، کم شدن هدر رفت منابع و سازگاری با تغییرات است. یک مثال از این دسته الگوی Proxy است که در مسیر ارتباط دو شی قرار می‌گیرد و می‌توان بدون ایجاد تغییر در شی‌های دیگر کاربرد هایی مثل caching یا logging را بین مسیر اضافه کرد.
<br/>
دسته سوم الگوهای رفتاری (Behavioral Patterns):
<br/>
این دسته از الگو‌ها، همانطور که از نامشان پیداست، بر رفتار و تعامل بین اشیاء مختلف در یک سیستم تمرکز دارند. الگو‌های رفتاری با الگوریتم‌ها و توزیع مسئولیت‌ها بین اشیا سر و کار دارند. الگو‌های State و Strategy که در این مخزن مورد استفاده قرار گرفته‌اند عضو دسته الگو‌های رفتاری هستند. 


### پرسش ۲
الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟

### پاسخ:
الگو‌های State و Strategy که در این مخزن مورد استفاده قرار گرفته‌اند عضو دسته الگو‌های رفتاری هستند. 

### پرسش ۳
با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.
### پاسخ:
برای ایجاد محصول از الگوی Singleton استفاده کردیم. زیرا کافی است که یک محصول (یا همان بسته) ایجاد شود و در صورت نیاز به اطلاعات محصول همان instance که در جای دیگری از کد ایجاد شده مورد استفاده قرار بگیرد (چون حالتی که دو محصول یا بسته متفاوت داشته باشیم نداریم). برای تحقق این الگو یک تابع با نام getInstance به کلاس Proudct افزودیم و از آن برای ایجاد (create) کردن شی Product استفاده می‌کنیم. در این تابع چک می‌کنیم که اگر یک شی از Product از قبل ایجاد شده آن شی برگردانده شود و در غیر این صورت یک Product (همان بسته) ایجاد شود. کد این قسمت در فایل [Product.java](./src/Product.java) آمده است.

### پرسش ۴
تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).
### پاسخ:
اصل SRP: این اصل در اکثر موارد تحقق می‌یابد اما این شانس وجود دارد که تحقق نیابد زیرا که وقتی یک کلاس Singleton باشد نمی‌تواند فرزند داشته باشد (وقتی یک کلاس A داریم که فرزند کلاس B است، یک نمونه از A اساساً نمونه B هم هست. بنابراین خود مفهوم ارث بردن خلاف مدل Singleton است.) در نتیجه همه وظایف که ممکن است نا مربوط باشند در یک کلاس جمع می‌شود و دیگر single responsibility نخواهیم داشت.
<br/>
اصل OCP: برای اینکه یک کلاس Open باشد، باید امکان ارث بردن از آن وجود داشته باشد. وراثت یک رابطه "is-a" است. اگر از یک کلاس Singleton به ارث ببریم شی‌های از کلاس فرزند به دلیل رابطه "is-a" شی‌هایی (instanceهایی) از کلاس والد هستند، به این معنی که می توانید چندین نمونه از کلاس Singleton داشته باشید که در نتیجه دیگر Singleton ندارید. اگر کلاس singleton از وراثت جلوگیری کند، دیگر Open نیست. در نتیجه به دلیل تناقض ذاتی Open بودن با تک نمونه ای بودن OCP تحقق نمی‌یابد. 
<br/>
اصل LSP: این اصل می‌گوید که اشیاء در یک برنامه باید بتوانند با نمونه‌هایی از فرزندان خود بدون تغییر در صحت برنامه قابل تعویض باشند. در اینجا به دلیل وجود کلمه فرزند باز تناقض با Singleton ایجاد می‌شود و این اصل نیز تحقق نمی‌یابد.
<br/>
اصل ISP: اگر کلاس singleton از رابط پیاده‌سازی نشود، همه وابستگی‌ها در همان کلاس جزئیات قرار می‌گیرند، هیچ انتزاع خاصی برای کلاینت وجود نخواهد داشت که باعث عدم تحقق این اصل می‌شود.
<br/>
اصل DIP: هر کلاینت همیشه برای دریافت instance مستقیماً به کلاس concrete وابسته است، در حالی که اصل پنجم سالید می‌گوید که ما باید به انتزاعات (abstractions) وابسته باشیم. در نتیجه این اصل نیز تحقق نمی‌یابد.
